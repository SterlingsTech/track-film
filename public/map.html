<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Live Package Tracker</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <style>
      body, html {
        margin: 0;
        padding: 0;
        height: 100%;
      }
      #map {
        width: 100%;
        height: 100%;
      }
      .icon-red    { color: red;    font-size: 16px; }
      .icon-orange { color: orange; font-size: 16px; }
      .icon-yellow { color: yellow; font-size: 16px; }
    </style>
  </head>
  <body>
    <div id="map"></div>
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script src="https://unpkg.com/@turf/turf/turf.min.js"></script>
    <script>
      const PROJECT = "goofy-rattle-casquette";
      const MAPBOX_TOKEN = "pk.eyJ1IjoiYXNpZGF0LXRlc3QiLCJhIjoiY21hM3ExbnNpMmt1NjJrc21hemppdHlmZyJ9.P8Olfvt6pYjiyzHHOkAG4g";

      const params = new URLSearchParams(window.location.search);
      const recId = params.get("recId");
      if (!recId) {
        alert("Please provide ?recId=<your-record-id> in the URL");
        throw new Error("recId missing");
      }

      const DATA_URL = `https://${PROJECT}.glitch.me/data/${recId}`;

      // initialize map
      const map = L.map("map").setView([51.505, -0.09], 13);
      L.tileLayer(
        `https://api.mapbox.com/styles/v1/{id}/tiles/{z}/{x}/{y}?access_token=${MAPBOX_TOKEN}`,
        { id: "mapbox/streets-v11", tileSize: 512, zoomOffset: -1 }
      ).addTo(map);

      // ── STOP AUTO‐FIT AFTER USER MOVES ──
      let userMoved = false;
      map.on("movestart", () => { userMoved = true; });
      // ─────────────────────────────────────

      function render() {
        fetch(DATA_URL)
          .then(r => r.json())
          .then(data => {
            // remove old overlays
            map.eachLayer(layer => {
              if (layer.options && layer.options.pane === "overlayPane") {
                map.removeLayer(layer);
              }
            });

            // draw address zones
            const addrFeat = data.features.find(f => f.properties.event === "address");
            if (addrFeat) {
              const [lng, lat] = addrFeat.geometry.coordinates;
              const p = turf.point([lng, lat]);

              L.geoJSON(turf.buffer(p, 100, { units: "meters" }), {
                style: { color: "orange", fillColor: "orange", fillOpacity: 0.2, weight: 2 }
              }).addTo(map);

              L.geoJSON(turf.buffer(p, 30, { units: "meters" }), {
                style: { color: "blue", fillColor: "lightblue", fillOpacity: 0.5, weight: 2 }
              }).addTo(map);

              L.geoJSON(turf.buffer(p, 15, { units: "meters" }), {
                style: { color: "green", fillColor: "lightgreen", fillOpacity: 0.2, weight: 2 }
              }).addTo(map);
            }

            // helper for trails
            function drawTrail(eventType, color, iconClass) {
              const feat = data.features.find(f => f.properties.event === eventType);
              if (!feat) return;
              const coords = feat.geometry.coordinates.map(c => [c[1], c[0]]);
              L.polyline(coords, { color, weight: 3 }).addTo(map);
              coords.forEach(([lat, lng]) => {
                L.marker([lat, lng], {
                  icon: L.divIcon({ html: '×', className: iconClass })
                }).addTo(map);
              });
            }
            drawTrail("route_in_transit", "red", "icon-red");
            drawTrail("route_tampered",   "orange", "icon-orange");
            drawTrail("route_stolen",     "yellow", "icon-yellow");

            // markers & popups with custom address popup
            L.geoJSON(data, {
              pointToLayer(feature, latlng) {
                const ev = feature.properties.event;
                const isOpened  = ev === "opened";
                const isAddress = ev === "address";
                const color = isOpened ? "grey" : isAddress ? "blue" : "green";
                const fill = isOpened ? "lightgrey" : isAddress ? "skyblue" : "lightgreen";

                const marker = L.circleMarker(latlng, {
                  radius: 8, color, fillColor: fill, fillOpacity: 1, weight: 2
                });

                // build popup html
                let html = `<strong>${ev.toUpperCase()}</strong><br>`;

                if (isAddress) {
                  html += `Name: ${feature.properties.customerName || "N/A"}<br>`;
                  html += `Address: ${feature.properties.customerAddress || "N/A"}`;
                } else {
                  html += `Status: ${feature.properties.status || "N/A"}<br>`;
                  html += `Left: ${feature.properties.left || "N/A"}<br>`;

                  if (ev === "delivered") {
                    if (feature.properties.deliveredTime) {
                      const dt = new Date(feature.properties.deliveredTime);
                      html += `Delivered At: ${dt.toLocaleString()}<br>`;
                    }
                    if (feature.properties.photoUrl) {
                      html += `<img src="${feature.properties.photoUrl}" alt="Delivery Photo" style="max-width:200px; margin-top:5px; display:block;"/>`;
                    }
                  }
                  else if (ev === "opened") {
                    if (feature.properties.openedTime) {
                      const ot = new Date(feature.properties.openedTime);
                      html += `Opened At: ${ot.toLocaleString()}<br>`;
                    }
                  }
                }

                marker.bindPopup(html);
                return marker;
              }
            }).addTo(map);

            // only auto-fit if user hasn't moved
            if (!userMoved) {
              const bounds = L.geoJSON(data).getBounds();
              map.fitBounds(bounds, { padding: [20, 20] });
            }
          });
      }

      render();
      setInterval(render, 10000);
    </script>
  </body>
</html>
